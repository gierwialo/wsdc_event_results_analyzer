<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WSDC Event results analyzer</title>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <style>
        :root {
            /* Color palette */
            --color-primary: #667eea;
            --color-primary-dark: #5568d3;
            --color-secondary: #764ba2;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-text-muted: #718096;
            --color-bg-light: #f7fafc;
            --color-border: #e2e8f0;

            /* Status colors */
            --color-success: #48bb78;
            --color-success-bg: #c6f6d5;
            --color-success-text: #22543d;
            --color-error: #f56565;
            --color-error-bg: #fed7d7;
            --color-error-text: #c53030;
            --color-warning-bg: #fff5f5;

            /* Medal colors */
            --color-gold: #d4af37;
            --color-silver: #c0c0c0;
            --color-bronze: #cd7f32;

            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 12px;
            --spacing-lg: 16px;
            --spacing-xl: 20px;
            --spacing-xxl: 24px;

            /* Border radius */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-secondary) 100%);
            min-height: 100vh;
            padding: var(--spacing-xl);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .card {
            background: white;
            border-radius: var(--radius-lg);
            padding: var(--spacing-xxl);
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            margin-bottom: var(--spacing-xl);
        }

        h1 {
            color: var(--color-text);
            margin-bottom: var(--spacing-sm);
            font-size: 28px;
        }

        .subtitle {
            color: var(--color-text-muted);
            margin-bottom: var(--spacing-xxl);
        }

        .input-group {
            display: flex;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        input[type="text"],
        input[type="url"] {
            flex: 1;
            padding: var(--spacing-md) var(--spacing-lg);
            border: 2px solid var(--color-border);
            border-radius: var(--radius-md);
            font-size: 14px;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus,
        input[type="url"]:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        button {
            padding: var(--spacing-md) var(--spacing-xxl);
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
        }

        button:hover:not(:disabled) {
            background: var(--color-primary-dark);
        }

        button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: var(--color-text-muted);
        }

        .spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid var(--color-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto var(--spacing-lg);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            padding: var(--spacing-md) var(--spacing-lg);
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-lg);
        }

        .alert-error {
            background: var(--color-error-bg);
            color: var(--color-error-text);
        }

        .alert-success {
            background: var(--color-success-bg);
            color: var(--color-success-text);
        }

        .event-info {
            background: var(--color-bg-light);
            padding: var(--spacing-lg);
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-xl);
        }

        .event-info h2 {
            color: var(--color-text);
            font-size: 20px;
            margin-bottom: var(--spacing-sm);
        }

        .event-info p {
            color: var(--color-text-light);
            margin: var(--spacing-xs) 0;
        }

        .judges-list {
            color: var(--color-text-muted);
            font-size: 14px;
            margin-top: var(--spacing-sm);
        }

        .results-header {
            margin-bottom: var(--spacing-lg);
            color: var(--color-text);
        }

        .table-wrapper {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: var(--spacing-lg);
        }

        thead {
            background: var(--color-bg-light);
        }

        th, td {
            padding: var(--spacing-md);
            text-align: left;
            border-bottom: 1px solid var(--color-border);
        }

        th {
            font-weight: 600;
            color: var(--color-text);
            font-size: 14px;
        }

        td {
            color: var(--color-text-light);
        }

        tbody tr:hover {
            background: var(--color-bg-light);
        }

        .place {
            font-weight: 700;
            color: var(--color-primary);
        }

        .place-1 { color: var(--color-gold); }
        .place-2 { color: var(--color-silver); }
        .place-3 { color: var(--color-bronze); }

        .judge-score {
            text-align: center;
            font-variant-numeric: tabular-nums;
        }

        .bib {
            font-weight: 600;
            color: var(--color-primary);
        }

        .calculated-place {
            font-weight: 600;
        }

        .place-match {
            color: var(--color-success);
        }

        .place-mismatch {
            color: var(--color-error);
            background: var(--color-warning-bg);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-sm);
        }

        .calc-details {
            font-size: 11px;
            color: var(--color-text-muted);
            margin-top: 2px;
        }

        /* Accessibility improvements */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Audit trail styles */
        .audit-subtitle {
            margin-bottom: var(--spacing-lg);
        }

        .audit-container {
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            background: var(--color-bg-light);
        }

        .audit-step {
            display: flex;
            gap: var(--spacing-md);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
            background: white;
            border-radius: var(--radius-sm);
            border-left: 3px solid var(--color-border);
        }

        .audit-step-init {
            border-left-color: var(--color-primary);
            background: #f0f4ff;
        }

        .audit-step-iteration {
            border-left-color: var(--color-text-muted);
        }

        .audit-step-check {
            border-left-color: #e2e8f0;
        }

        .audit-step-tie {
            border-left-color: #f59e0b;
            background: #fffbeb;
        }

        .audit-step-assign {
            border-left-color: var(--color-success);
            background: #f0fdf4;
            font-weight: 500;
        }

        .audit-step-number {
            flex-shrink: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--color-bg-light);
            border-radius: 50%;
            font-size: 12px;
            font-weight: 600;
            color: var(--color-text-muted);
        }

        .audit-step-content {
            flex: 1;
        }

        .audit-step-message {
            color: var(--color-text);
            margin-bottom: var(--spacing-xs);
            line-height: 1.5;
        }

        .audit-step-meta {
            display: flex;
            gap: var(--spacing-sm);
            flex-wrap: wrap;
        }

        .audit-meta-badge {
            display: inline-block;
            padding: 2px 8px;
            background: var(--color-bg-light);
            border-radius: var(--radius-sm);
            font-size: 11px;
            color: var(--color-text-muted);
            font-family: 'Courier New', monospace;
        }

        /* Legend styles */
        .legend-container {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg);
            background: white;
            border-radius: var(--radius-md);
            border: 2px solid var(--color-border);
        }

        .legend-title {
            color: var(--color-text);
            font-size: 18px;
            margin-bottom: var(--spacing-lg);
            border-bottom: 2px solid var(--color-border);
            padding-bottom: var(--spacing-sm);
        }

        .legend-section {
            margin-bottom: var(--spacing-lg);
        }

        .legend-section:last-child {
            margin-bottom: 0;
        }

        .legend-section-title {
            color: var(--color-text);
            font-size: 14px;
            margin-bottom: var(--spacing-md);
            font-weight: 600;
        }

        .legend-items {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            color: var(--color-text-light);
            font-size: 14px;
            line-height: 1.6;
        }

        .legend-color {
            display: inline-block;
            width: 24px;
            height: 24px;
            border-radius: var(--radius-sm);
            flex-shrink: 0;
            border: 2px solid var(--color-border);
        }

        .legend-color-init {
            background: #f0f4ff;
            border-color: var(--color-primary);
        }

        .legend-color-iteration {
            background: white;
            border-color: var(--color-text-muted);
        }

        .legend-color-check {
            background: white;
            border-color: #e2e8f0;
        }

        .legend-color-tie {
            background: #fffbeb;
            border-color: #f59e0b;
        }

        .legend-color-assign {
            background: #f0fdf4;
            border-color: var(--color-success);
        }

        .legend-description {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .legend-description p {
            color: var(--color-text-light);
            font-size: 14px;
            line-height: 1.6;
            margin: 0;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            body {
                padding: var(--spacing-md);
            }

            .card {
                padding: var(--spacing-lg);
            }

            .input-group {
                flex-direction: column;
            }

            button {
                width: 100%;
            }

            .audit-container {
                max-height: 400px;
            }

            .audit-step {
                flex-direction: column;
                gap: var(--spacing-sm);
            }
        }
    </style>
</head>
<body>
    <div class="container" x-data="resultsAnalyzer">
        <div class="card">
            <h1>ðŸ“Š WSDC Event results analyzer</h1>
            <p class="subtitle">Paste a link to results from scoring.dance</p>

            <div class="input-group">
                <input
                    type="url"
                    x-model="url"
                    placeholder="Direct link to scoring.dance event result"
                    @keyup.enter.debounce.500ms="loadResults()"
                    aria-label="Event results URL"
                    :aria-invalid="!!error"
                >
                <button
                    @click="loadResults()"
                    :disabled="loading || !url"
                    :aria-busy="loading"
                >
                    <span x-show="!loading">Load</span>
                    <span x-show="loading">Loading...</span>
                </button>
            </div>

            <div x-show="error" class="alert alert-error" role="alert" x-text="error"></div>
            <div x-show="successMessage" class="alert alert-success" role="status" x-text="successMessage"></div>
        </div>

        <div x-show="loading" class="card" aria-live="polite" aria-busy="true">
            <div class="loading">
                <div class="spinner" role="status" aria-label="Loading results"></div>
                <p>Fetching data from scoring.dance...</p>
            </div>
        </div>

        <div x-show="results && !loading" class="card">
            <div class="event-info" x-show="eventInfo">
                <h2 x-text="eventInfo?.name"></h2>
                <p><strong>Category:</strong> <span x-text="eventInfo?.category"></span></p>
                <p><strong>Date:</strong> <span x-text="eventInfo?.date"></span></p>
                <p><strong>Location:</strong> <span x-text="eventInfo?.location"></span></p>
                <p class="judges-list"><strong>Judges:</strong> <span x-text="eventInfo?.judges"></span></p>
                <p><strong>Scoring system:</strong> <span x-text="eventInfo?.calculationModel"></span></p>
            </div>

            <h3 class="results-header">
                Results (<span x-text="results?.length || 0"></span> couples)
            </h3>

            <div class="table-wrapper">
                <table>
                    <caption class="visually-hidden">Competition results with judge scores and calculated placements</caption>
                    <thead>
                        <tr>
                            <th scope="col">Place</th>
                            <th scope="col">Calc Place</th>
                            <th scope="col">Bib</th>
                            <th scope="col">Leader</th>
                            <th scope="col">Follower</th>
                            <template x-for="judge in judges" :key="judge">
                                <th scope="col" class="judge-score" x-text="judge"></th>
                            </template>
                        </tr>
                    </thead>
                    <tbody>
                        <template x-for="result in results" :key="`${result.leaderBib}-${result.followerBib}`">
                            <tr>
                                <td>
                                    <span
                                        class="place"
                                        :class="'place-' + result.place"
                                        x-text="result.place"
                                    ></span>
                                </td>
                                <td>
                                    <div>
                                        <span
                                            class="calculated-place"
                                            :class="result.calculatedPlace === result.place ? 'place-match' : 'place-mismatch'"
                                            x-text="result.calculatedPlace || '?'"
                                            :title="result.calculatedPlace === result.place ? 'Match' : 'Mismatch'"
                                        ></span>
                                        <div class="calc-details" x-show="result.calcDetails">
                                            <span x-text="result.calcDetails"></span>
                                        </div>
                                    </div>
                                </td>
                                <td>
                                    <span class="bib" x-text="result.leaderBib"></span> /
                                    <span class="bib" x-text="result.followerBib"></span>
                                </td>
                                <td x-text="result.leader"></td>
                                <td x-text="result.follower"></td>
                                <template x-for="judge in judges" :key="judge">
                                    <td class="judge-score" x-text="result.scores?.[judge] || '-'"></td>
                                </template>
                            </tr>
                        </template>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Step-by-step breakdown -->
        <div x-show="auditTrail && !loading" class="card">
            <h3 class="results-header">
                ðŸ“‹ Step-by-Step Calculation Breakdown
            </h3>
            <p class="subtitle audit-subtitle">
                Follow how the RPSS algorithm determines each placement, step by step.
            </p>

            <div class="audit-container">
                <template x-for="step in auditTrail" :key="step.step">
                    <div class="audit-step" :class="'audit-step-' + step.type">
                        <div class="audit-step-number">
                            <span x-text="step.step"></span>
                        </div>
                        <div class="audit-step-content">
                            <div class="audit-step-message" x-text="step.message"></div>
                            <div x-show="step.k" class="audit-step-meta">
                                <span class="audit-meta-badge">k = <span x-text="step.k"></span></span>
                                <span x-show="step.majorityCount" class="audit-meta-badge">
                                    Majority: <span x-text="step.majorityCount"></span>/<span x-text="auditInfo?.totalJudges"></span>
                                </span>
                                <span x-show="step.sum" class="audit-meta-badge">
                                    Sum: <span x-text="step.sum"></span>
                                </span>
                            </div>
                        </div>
                    </div>
                </template>
            </div>

            <!-- Legend -->
            <div class="legend-container">
                <h4 class="legend-title">ðŸ“– Legend & Terminology</h4>

                <div class="legend-section">
                    <h5 class="legend-section-title">Step Types (Colors)</h5>
                    <div class="legend-items">
                        <div class="legend-item">
                            <span class="legend-color legend-color-init"></span>
                            <strong>Init</strong> - Algorithm initialization
                        </div>
                        <div class="legend-item">
                            <span class="legend-color legend-color-iteration"></span>
                            <strong>Iteration</strong> - Starting new place calculation
                        </div>
                        <div class="legend-item">
                            <span class="legend-color legend-color-check"></span>
                            <strong>Check</strong> - Checking couples at level k
                        </div>
                        <div class="legend-item">
                            <span class="legend-color legend-color-tie"></span>
                            <strong>Tie</strong> - Multiple couples tied, need tie-break
                        </div>
                        <div class="legend-item">
                            <span class="legend-color legend-color-assign"></span>
                            <strong>Assign</strong> - Place successfully assigned to couple
                        </div>
                    </div>
                </div>

                <div class="legend-section">
                    <h5 class="legend-section-title">Key Terms</h5>
                    <div class="legend-items">
                        <div class="legend-item">
                            <strong>k</strong> - Current placement level being checked (e.g., k=2 means checking how many judges placed couple in top 2)
                        </div>
                        <div class="legend-item">
                            <strong>Majority</strong> - Minimum number of judges needed (>50%) to determine a placement. Formula: floor(J/2) + 1
                        </div>
                        <div class="legend-item">
                            <strong>maj</strong> - How many judges gave this couple a placement â‰¤ k (e.g., maj=5/7 means 5 out of 7 judges)
                        </div>
                        <div class="legend-item">
                            <strong>Sum</strong> - Sum of ordinal placements â‰¤ k, used to break ties (lower is better)
                        </div>
                        <div class="legend-item">
                            <strong>Ordinals</strong> - Individual judge placements (rankings) for each couple
                        </div>
                    </div>
                </div>

                <div class="legend-section">
                    <h5 class="legend-section-title">How RPSS Works</h5>
                    <div class="legend-description">
                        <p><strong>1. Majority Rule:</strong> A couple gets a placement when a majority of judges (>50%) rank them at that level or better.</p>
                        <p><strong>2. Level-by-level:</strong> Start at k=1 (1st place), then k=2 (top 2), k=3 (top 3), etc., until someone has majority.</p>
                        <p><strong>3. Tie-breaking:</strong> If multiple couples have the same majority count, use sum of their ordinals â‰¤ k (lower sum wins).</p>
                        <p><strong>4. Expand k:</strong> If still tied after sum, expand to k+1, k+2, etc., and compare majority counts at higher levels.</p>
                        <p><strong>5. Head-to-head:</strong> Final tie-breaker for 2 couples: count which couple is ranked higher by more judges.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration constants
        const CONFIG = {
            MAX_RPSS_ITERATIONS: 1000,
            SUCCESS_MESSAGE_TIMEOUT: 5000,
            ALLOWED_DOMAIN: 'scoring.dance',
            CORS_PROXY_URL: 'https://api.allorigins.win/raw?url=',
            DEV_MODE: false // Set to true to enable console logging
        };

        // Utility functions
        const logger = {
            log: (...args) => CONFIG.DEV_MODE && console.log(...args),
            error: (...args) => console.error(...args),
            warn: (...args) => CONFIG.DEV_MODE && console.warn(...args)
        };

        const validateURL = (url) => {
            try {
                const urlObj = new URL(url);
                if (!urlObj.hostname.includes(CONFIG.ALLOWED_DOMAIN)) {
                    throw new Error(`URL must be from ${CONFIG.ALLOWED_DOMAIN}`);
                }
                return true;
            } catch (e) {
                throw new Error('Invalid URL format');
            }
        };

        const sanitizeHTML = (str) => {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        };

        // RPSS Algorithm - Validation
        const validateOrdinals = (ordinals, judge_ids, C) => {
            for (let j = 0; j < ordinals.length; j++) {
                const seen = new Set();
                for (let c = 0; c < C; c++) {
                    const ord = ordinals[j][c];
                    if (ord < 1 || ord > C || seen.has(ord)) {
                        throw new Error(`Judge ${judge_ids[j]} has invalid ordinals (duplicates or out of range)`);
                    }
                    seen.add(ord);
                }
            }
        };

        // RPSS Algorithm - Find couples with majority at level k
        const findMajorityWinners = (remaining, ordinals, k, majority) => {
            const counts = {};
            for (const c of remaining) {
                counts[c] = 0;
                for (let j = 0; j < ordinals.length; j++) {
                    if (ordinals[j][c] <= k) {
                        counts[c]++;
                    }
                }
            }

            const eligible = [];
            for (const c of remaining) {
                if (counts[c] >= majority) {
                    eligible.push(c);
                }
            }

            return { counts, eligible };
        };

        // RPSS Algorithm - Calculate sum of ordinals <= k
        const calculateSums = (tier, ordinals, k) => {
            const sums = {};
            for (const c of tier) {
                const ordsForC = [];
                for (let j = 0; j < ordinals.length; j++) {
                    if (ordinals[j][c] <= k) {
                        ordsForC.push(ordinals[j][c]);
                    }
                }
                sums[c] = ordsForC.reduce((a, b) => a + b, 0);
            }
            return sums;
        };

        // RPSS Algorithm - Head to head comparison
        const headToHeadWinner = (c1, c2, ordinals, majority) => {
            let c1_wins = 0;
            for (let j = 0; j < ordinals.length; j++) {
                if (ordinals[j][c1] < ordinals[j][c2]) {
                    c1_wins++;
                }
            }
            return c1_wins >= majority ? c1 : c2;
        };

        // RPSS Algorithm - Main function
        const compute_relative_placement = (ordinals, couple_ids, judge_ids) => {
            if (!ordinals || ordinals.length === 0 || !ordinals[0]) {
                throw new Error('Invalid ordinals data');
            }

            const J = ordinals.length;
            const C = ordinals[0].length;

            validateOrdinals(ordinals, judge_ids, C);

            const majority = Math.floor(J / 2) + 1;
            const placements = [];
            const audit = { majority, steps: [], totalJudges: J, totalCouples: C };
            const remaining = new Set([...Array(C).keys()]);
            let place = 1;
            let iteration = 0;
            let stepNumber = 1;

            audit.steps.push({
                step: stepNumber++,
                type: 'init',
                message: `Starting RPSS calculation with ${J} judges and ${C} couples. Majority = ${majority}`
            });

            while (remaining.size > 0 && iteration < CONFIG.MAX_RPSS_ITERATIONS) {
                iteration++;
                let k = 1;
                let assigned_at_this_level = false;

                audit.steps.push({
                    step: stepNumber++,
                    type: 'iteration',
                    message: `Starting iteration for place ${place}. Remaining couples: ${Array.from(remaining).map(c => couple_ids[c]).join(', ')}`
                });

                while (k <= C) {
                    const { counts, eligible } = findMajorityWinners(remaining, ordinals, k, majority);

                    audit.steps.push({
                        step: stepNumber++,
                        type: 'check',
                        k: k,
                        counts: {...counts},
                        eligible: eligible.map(c => couple_ids[c]),
                        message: `Checking k=${k}: ${eligible.length > 0 ? `${eligible.length} couple(s) have majority` : 'No couples have majority yet'}`
                    });

                    if (eligible.length === 0) {
                        k++;
                        continue;
                    }

                    const maxCount = Math.max(...eligible.map(c => counts[c]));
                    const tier = eligible.filter(c => counts[c] === maxCount);

                    if (tier.length === 1) {
                        const c = tier[0];
                        audit.steps.push({
                            step: stepNumber++,
                            type: 'assign',
                            place: place,
                            couple: couple_ids[c],
                            k: k,
                            majorityCount: maxCount,
                            message: `âœ“ Assigned place ${place} to ${couple_ids[c]} (majority: ${maxCount}/${J} at kâ‰¤${k})`
                        });
                        placements.push({
                            place: place++,
                            couple_id: couple_ids[c],
                            couple_index: c,
                            k_used: k,
                            majority_count: maxCount
                        });
                        remaining.delete(c);
                        assigned_at_this_level = true;

                        const stillEligible = [];
                        for (const c2 of remaining) {
                            if (counts[c2] >= majority) {
                                stillEligible.push(c2);
                            }
                        }
                        if (stillEligible.length > 0) {
                            continue;
                        } else {
                            break;
                        }
                    } else {
                        // Tie-break
                        audit.steps.push({
                            step: stepNumber++,
                            type: 'tie',
                            couples: tier.map(c => couple_ids[c]),
                            message: `âš  Tie between ${tier.length} couples: ${tier.map(c => couple_ids[c]).join(', ')}. Using sum of ordinals â‰¤${k} to break tie.`
                        });

                        const sums = calculateSums(tier, ordinals, k);
                        const bestSum = Math.min(...tier.map(c => sums[c]));
                        const tied2 = tier.filter(c => sums[c] === bestSum);

                        const sumsInfo = tier.map(c => `${couple_ids[c]}: sum=${sums[c]}`).join(', ');
                        audit.steps.push({
                            step: stepNumber++,
                            type: 'tie-sums',
                            sums: Object.fromEntries(tier.map(c => [couple_ids[c], sums[c]])),
                            message: `Ordinal sums at kâ‰¤${k}: ${sumsInfo}`
                        });

                        if (tied2.length === 1) {
                            const c = tied2[0];
                            audit.steps.push({
                                step: stepNumber++,
                                type: 'assign',
                                place: place,
                                couple: couple_ids[c],
                                k: k,
                                majorityCount: maxCount,
                                sum: sums[c],
                                message: `âœ“ Assigned place ${place} to ${couple_ids[c]} (sum: ${sums[c]}, best among tied)`
                            });
                            placements.push({
                                place: place++,
                                couple_id: couple_ids[c],
                                couple_index: c,
                                k_used: k,
                                majority_count: maxCount,
                                sum_used: sums[c]
                            });
                            remaining.delete(c);
                            assigned_at_this_level = true;
                            continue;
                        } else {
                            // Expand k
                            let k2 = k + 1;
                            let resolved = false;

                            while (k2 <= C && !resolved) {
                                const { counts: counts2 } = findMajorityWinners(new Set(tied2), ordinals, k2, majority);
                                const maxCount2 = Math.max(...tied2.map(c => counts2[c]));
                                const tied3 = tied2.filter(c => counts2[c] === maxCount2);

                                if (tied3.length === 1) {
                                    const c = tied3[0];
                                    placements.push({
                                        place: place++,
                                        couple_id: couple_ids[c],
                                        couple_index: c,
                                        k_used: k2,
                                        majority_count: maxCount2,
                                        tiebreak: 'expanded_k'
                                    });
                                    remaining.delete(c);
                                    resolved = true;
                                    assigned_at_this_level = true;
                                    break;
                                }

                                if (k2 === C) {
                                    if (tied3.length === 2) {
                                        const [c1, c2] = tied3;
                                        const winner = headToHeadWinner(c1, c2, ordinals, majority);
                                        const loser = winner === c1 ? c2 : c1;

                                        placements.push({
                                            place: place++,
                                            couple_id: couple_ids[winner],
                                            couple_index: winner,
                                            k_used: C,
                                            majority_count: maxCount2,
                                            tiebreak: 'head_to_head'
                                        });
                                        remaining.delete(winner);

                                        if (remaining.has(loser)) {
                                            placements.push({
                                                place: place++,
                                                couple_id: couple_ids[loser],
                                                couple_index: loser,
                                                k_used: C,
                                                majority_count: counts2[loser],
                                                tiebreak: 'head_to_head_loser'
                                            });
                                            remaining.delete(loser);
                                        }
                                    } else {
                                        // Multiway tie
                                        for (const c of tied3) {
                                            placements.push({
                                                place: place,
                                                couple_id: couple_ids[c],
                                                couple_index: c,
                                                k_used: C,
                                                majority_count: maxCount2,
                                                tiebreak: 'unresolved_multiway'
                                            });
                                            remaining.delete(c);
                                        }
                                        place += tied3.length;
                                    }
                                    resolved = true;
                                    assigned_at_this_level = true;
                                    break;
                                }
                                k2++;
                            }

                            if (resolved) {
                                break;
                            } else {
                                logger.warn('RPSS: Could not resolve tie, assigning all to same place', tied2);
                                for (const c of tied2) {
                                    placements.push({
                                        place: place,
                                        couple_id: couple_ids[c],
                                        couple_index: c,
                                        k_used: k,
                                        majority_count: maxCount,
                                        tiebreak: 'unresolved'
                                    });
                                    remaining.delete(c);
                                }
                                place += tied2.length;
                                assigned_at_this_level = true;
                                break;
                            }
                        }
                    }

                    if (assigned_at_this_level) {
                        break;
                    }
                }

                if (!assigned_at_this_level && remaining.size > 0) {
                    logger.error('RPSS: Could not assign any couple at this iteration');
                    for (const c of remaining) {
                        placements.push({
                            place: place++,
                            couple_id: couple_ids[c],
                            couple_index: c,
                            k_used: C,
                            majority_count: 0,
                            tiebreak: 'emergency_assignment'
                        });
                    }
                    break;
                }
            }

            if (iteration >= CONFIG.MAX_RPSS_ITERATIONS) {
                logger.error('RPSS: Max iterations exceeded');
            }

            return { placements, audit };
        };

        // Data parsing functions
        const parseEventData = (eventData, judgesSet) => {
            const locationParts = [];
            if (eventData.location?.name) locationParts.push(eventData.location.name);
            if (eventData.location?.country) locationParts.push(eventData.location.country);

            return {
                name: eventData.name || '',
                category: eventData.category || eventData.division || '',
                date: eventData.startDate ? new Date(eventData.startDate).toLocaleDateString('en-US') : '',
                location: locationParts.join(', '),
                judges: Array.from(judgesSet).join(', '),
                calculationModel: eventData.calculation_model || eventData.result[0]?.calculation_model || ''
            };
        };

        const parseResults = (eventData) => {
            return eventData.result.map(result => {
                const scores = {};
                if (result.scores) {
                    result.scores.forEach(score => {
                        scores[score.name] = score.placement;
                    });
                }

                return {
                    place: result.placement,
                    leader: result.dancer?.leader?.fullname || '',
                    leaderBib: result.dancer?.leader?.bib || '',
                    follower: result.dancer?.follower?.fullname || '',
                    followerBib: result.dancer?.follower?.bib || '',
                    scores: scores
                };
            });
        };

        const calculateRPSS = (results, judges) => {
            const C = results.length;
            const J = judges.length;

            const couple_ids = results.map(r => `${r.leaderBib}/${r.followerBib}`);
            const ordinals = [];

            for (let j = 0; j < J; j++) {
                const judgeName = judges[j];
                const judgeOrdinals = [];
                for (let c = 0; c < C; c++) {
                    const placement = parseInt(results[c].scores[judgeName]);
                    if (isNaN(placement)) {
                        throw new Error(`Invalid placement for judge ${judgeName}, couple ${c}`);
                    }
                    judgeOrdinals.push(placement);
                }
                ordinals.push(judgeOrdinals);
            }

            logger.log('Calling RPSS with ordinals:', ordinals);
            const rpssResult = compute_relative_placement(ordinals, couple_ids, judges);
            logger.log('RPSS calculation completed:', rpssResult);

            return rpssResult;
        };

        const mapCalculatedPlaces = (results, rpssResult) => {
            const calcPlaceMap = {};
            rpssResult.placements.forEach(p => {
                calcPlaceMap[p.couple_id] = {
                    place: p.place,
                    k_used: p.k_used,
                    majority_count: p.majority_count,
                    sum_used: p.sum_used,
                    tiebreak: p.tiebreak
                };
            });

            results.forEach(result => {
                const coupleId = `${result.leaderBib}/${result.followerBib}`;
                const calcData = calcPlaceMap[coupleId];
                if (calcData) {
                    result.calculatedPlace = calcData.place;

                    const details = [];
                    details.push(`k=${calcData.k_used}`);
                    details.push(`maj=${calcData.majority_count}`);
                    if (calcData.sum_used) {
                        details.push(`sum=${calcData.sum_used}`);
                    }
                    if (calcData.tiebreak) {
                        details.push(calcData.tiebreak);
                    }
                    result.calcDetails = details.join(', ');
                } else {
                    result.calculatedPlace = '?';
                    result.calcDetails = 'error';
                }
            });
        };

        // Alpine.js data
        document.addEventListener('alpine:init', () => {
            Alpine.data('resultsAnalyzer', () => ({
                url: '',
                loading: false,
                error: '',
                successMessage: '',
                results: null,
                eventInfo: null,
                judges: [],
                successTimeout: null,
                auditTrail: null,
                auditInfo: null,

                async loadResults() {
                    if (!this.url) return;

                    // Clear previous messages
                    this.error = '';
                    this.successMessage = '';
                    if (this.successTimeout) {
                        clearTimeout(this.successTimeout);
                    }

                    // Validate URL
                    try {
                        validateURL(this.url);
                    } catch (e) {
                        this.error = e.message;
                        return;
                    }

                    this.loading = true;
                    this.results = null;
                    this.eventInfo = null;
                    this.auditTrail = null;
                    this.auditInfo = null;

                    logger.log('Starting to load results from:', this.url);

                    try {
                        // Fetch data
                        let html;
                        try {
                            logger.log('Fetching directly...');
                            const response = await fetch(this.url);
                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }
                            html = await response.text();
                            logger.log('Direct fetch successful');
                        } catch (corsError) {
                            logger.log('Direct fetch failed, using proxy...');
                            const proxyUrl = `${CONFIG.CORS_PROXY_URL}${encodeURIComponent(this.url)}`;
                            const response = await fetch(proxyUrl);
                            if (!response.ok) {
                                throw new Error('Unable to fetch data. Please check the URL or try again later.');
                            }
                            html = await response.text();
                            logger.log('Proxy fetch successful');
                        }

                        // Parse HTML
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');

                        // Look for JSON-LD with results
                        const scripts = doc.querySelectorAll('script[type="application/ld+json"]');
                        let eventData = null;

                        scripts.forEach(script => {
                            try {
                                const data = JSON.parse(script.textContent);
                                if (data['@type'] === 'Event' && data.result && Array.isArray(data.result)) {
                                    eventData = data;
                                }
                            } catch (e) {
                                logger.error('Error parsing JSON-LD:', e);
                            }
                        });

                        if (!eventData || !eventData.result || eventData.result.length === 0) {
                            throw new Error('No results data found on the page. Please ensure this is a valid results page.');
                        }

                        // Collect judges
                        const judgesSet = new Set();
                        if (eventData.result[0]?.scores) {
                            eventData.result[0].scores.forEach(score => {
                                judgesSet.add(score.name);
                            });
                        }
                        this.judges = Array.from(judgesSet);

                        // Parse event info
                        this.eventInfo = parseEventData(eventData, judgesSet);

                        // Parse results
                        this.results = parseResults(eventData);
                        this.results.sort((a, b) => a.place - b.place);

                        // Calculate RPSS placements
                        try {
                            logger.log('Starting RPSS calculation...');
                            const rpssResult = calculateRPSS(this.results, this.judges);
                            mapCalculatedPlaces(this.results, rpssResult);

                            // Store audit trail for step-by-step breakdown
                            this.auditTrail = rpssResult.audit.steps;
                            this.auditInfo = {
                                majority: rpssResult.audit.majority,
                                totalJudges: rpssResult.audit.totalJudges,
                                totalCouples: rpssResult.audit.totalCouples
                            };
                        } catch (rpssError) {
                            logger.error('RPSS calculation error:', rpssError);
                            this.results.forEach(result => {
                                result.calculatedPlace = 'ERR';
                                result.calcDetails = 'Calculation error';
                            });
                            this.auditTrail = null;
                            this.auditInfo = null;
                        }

                        this.successMessage = `Successfully loaded ${this.results.length} results!`;

                        // Auto-hide success message after 5 seconds
                        this.successTimeout = setTimeout(() => {
                            this.successMessage = '';
                        }, CONFIG.SUCCESS_MESSAGE_TIMEOUT);

                    } catch (err) {
                        // User-friendly error messages
                        let errorMessage = 'An error occurred while loading results. ';

                        if (err.message.includes('fetch')) {
                            errorMessage += 'Unable to connect to the server. Please check your internet connection.';
                        } else if (err.message.includes('No results data')) {
                            errorMessage = err.message;
                        } else {
                            errorMessage += err.message;
                        }

                        this.error = errorMessage;
                        logger.error('Error loading results:', err);
                    } finally {
                        this.loading = false;
                    }
                }
            }));
        });
    </script>
</body>
</html>
